### HW01 CLI

# Архитектура

Наше приложение состоит из трех основных компонент: **Parser**, **Controller** и **Command Executor**. **Parser** отвечает за обработку пришедшей строки, на выход выдает некое представление `List<Command>`, **CommandExecutor** отвечает за запуск соответсвующих комманд, **Controller** отвечает за взаимодействие между **Parser** и **Command Executor**. Разберем каждую из компонент подробнее.

## Parser
Состоит из `Lexer`, `Parser`, `Token` и `InputPreprocessor`.
* `InputPreprocessor`. Содержит единственный метод `substitute()`, который осуществляет подстановку переменных окружения, строя новую строку с уже подставленными значениями при помощи следующего алгоритма:
    * Назовем кавычки внешними, если они не содержатся внутри других кавычек. Идем по каждому символу строки. Если встретили знак `$` и при этом мы **не** находимся внутри внешних одинарных кавычек, то далее идем по каждому следующему символу до тех пор, пока не встретим пробел или другую кавычку любого типа или символ пайплайна `'|'` и вместо полученного имени переменной достаем из окружения соответствующее значение переменной и в результирующую строку добавляем именно значение переменной.
* `Lexer`. Представляет интерфейс обычного лексера с единственным методом `getNextToken()`. Конкретно в нашей реализации имеет имплементацию `LexerImpl`, которая разбивает текст на токены из `Token`.
* `Token`. Enum, который хранит в себе следующие токены:
    * _str_: строка без пробелов
    * _str_in1_: строка с пробелами, которая обернута в двойные кавычки
    * _str_in2_: строка с пробелами, которая обернута в одинарные кавычки
    * _assign_: =
    * _pipe_: |
    * _space_: один или несколько пробелов

  При получении значений токенов _str_in1_ и _str_in2_ кавычки по краям удаляются.
* Грамматика:
  ```
  Expression := Command (pipe Command)*
  Command := (Assignment | (String space Args?)) space?
  Assignment := str space? assign space? String
  Args := String (String space)* 
  String := str | str_in1 | str_in2
  ```
  Терминалу Command соответствует класс `Command`, который содержит имя команды(String) и список аргументов(List<String>). Экземпляр класса `Command` строится в процесе парсинга одной команды. Для `AssigmentCommand` аргументами будут имя создаваемой переменной и её значение.
* `Parser`. Интерфейс парсера. Стандартная имплементация(`ParserImpl`) принимает в конструкторе строку, которая в дальнейшем парсится в методе `parse()`. `Parser` использует `Lexer`, постепенно получая из него новые токены, которые обрабатываются при помощи соответствующей грамматики. Попутно строится список `Command`, который возвращается в результате метода `parse()`.

## Controller
Представлен классами Main и Environment.

* `Main`. В этом классе исполняется главный цикл нашей программы:
    * В цикле считываем пользовательский ввод как строку.
    * Выполняем обработку входной строки, выполняя все подстановки с помощью метода substitute у объекта класса InputPreprocessor, на выход получаем новую строку.
    * С помощью вызова метода parse у объекта класса Parser мы разбиваем строку на Token-ы с помощью лексера и парсим строку во внутреннее представление List<Command>
    * Далее вызываем Executor::execute и запускаем вычисление в List<Command>. На выходе получим ExecutionResult, сигнализирующий о том, закончилось вычисление успехом, ошибкой или прекратилось из-за вызова команды exit.
    * В конце мы обрабатываем результат вычисления, передав его в функцию `CheckResult()`, и можем вывести либо сообщение об ошибке, либо результат выполнения переданного выражения в зависимости от результата.

* `Environment`. Singleton, являющийся обёрткой вокруг отображения из имени переменной в её значение для операции присвоения.
    * Отображения хранятся в `HashMap<String, String>`
    * Имеется флаг `isShutdowned` типа `Boolean`, который становится `true` в момент исполнения команды exit. После этого момента все дальнейшие вычисления производиться не будут.
    * `Environment::put` модифицирует окружение с помощью пары <имя переменной, значение переменной>

На данный момент не предусмотрена смена Environment-a при перемещении между директориями.

## Command Executor

* `CommandStorage`. Хранилице наших команд, которые предстваляет из себя класс с полем storage: HashMap<String, Abstract Command> и методом getCommand(String): Abstract Command, который обращается к storage. Ключи - названия всех команд, значения - экземпляры соответствующих им классов, которые инициализируются при запуске приложения в конструкторе CommandStorage.
* `IOEnvironment`. Класс с двумя полями:
    * _inputStream_: аргументы для текущей команды
    * _outputStream_: результат и логи предыдущей команды
* `AbstractCommand`. Каждая команда в CLI -- это отдельный класс, который наследуется от него. Чтобы добавить новую команду необходимо просто отнаследоваться от AbstractCommand и реализовать метод execute(IOEnvironment): Result, который принимает потоки для чтения и записи, а сам метод внутри выполняет команду.
    * `EchoCommand`: читает из inputStream и сразу же пишет в outputStream
    * `CatCommand`: последовательно открывает файлы из inputStream и записывает их содержимое(также последовательно) в outputStream
    * `PwdCommand`: игнорирует inputStream, записывает текущую директорию в outputStream
    * `WcCommand`: пытается найти файл из inputStream, если не находит, то создаёт временный файл, записывает в outputStream количества строк, слов и байт полученного файла
    * `ExitCommand`: игнорирует inputStream, устанавливает isShutdowned в Environment -- в true, очичает outputStream
    * `AssignmentCommand`: вытаскивает из inputStream название переменной и её значение, в добавляет эту переменную в vars из Environment, очичает outputStream
    * `ExternalCommand`: вытаскиваем команду и аргументы из inputStream, выставляем переменные окружения и исполняем внешнюю команду с помощью ProcessBuilder
    * `GrepCommand`: исполняем поиск по образцу в переданном файле (или в том, что лежит в inputStream после пайпа). Для разбора аргументов командной строки использовалась библиотека [kotlinx-cli](https://github.com/Kotlin/kotlinx-cli), так как у неё много звёзд на гитхабе, она простая в использовании, верифицирована разработчиками котлина и полностью удовлетворяет нашим требованиям. Так же рассматривалась [kotlin-argparser](https://github.com/xenomachina/kotlin-argparser) - тоже хорошая либа, но разработчик перестал поддерживать её. Ещё можно было использовать [jcommander](http://jcommander.org) или [picocli](https://picocli.info) - неплохие библиотеки, но изначально для java. 
* `Executor`. Класс с методом `execute(List<Command>): Void` принимает `List<Command>`, то есть результат парсера. Он владеет `IOEnvironment`. У каждой команды из `List<Command>` последовательно будет вызван метод `execute(List<String>, IOEnvironment): Result`, в который будет передан List<String> с аргументами для этой команды, а _outputStream_ из `IOEnvironment` будет использован как поток для результата команды. В случае пайплайна результат предыдущей инструкции передается через поток ввода следующей инструкции, то есть после выполнения текущей инструкции нам нужно будет записать в _inputStream_ результат команды, а именно то, что записалось в _outputStream_.
* Многопоточность. Наше приложение многопоточность не поддерживает. Если какая-то команда будет выполняться в многопоточном режиме и как-то менять переменные окружения, то эти изменения никак не отразятся на результате, потому что подстановка переменных окружения происходит до запуска всех команд. Также если и делать поддержку многопоточности в пайплайне, то нужно аккуратно следить за потоками ввода-вывода в `IOEnvironment`.

## Диаграмма Классов

<p align="center">
  <img src="ArchitectureCLI.png" width="1000" title="screen_authorization">
</p>
